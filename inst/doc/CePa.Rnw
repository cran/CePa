% \VignetteIndexEntry{CePa Vignette}
% \VignetteDepends{CePa}
% \VignetteKeywords{Pathway Enrichment Analysis}
% \VignettePackage{CePa}



\documentclass[a4paper]{article}

\title{Centrality-based Pathway Enrichment}

\author{Zuguang Gu}

\usepackage{Sweave}
\begin{document}

\maketitle 
\section{Introduction}
Gene set enrichment analysis is broadly used in microarray data analysis \cite{Khatri2005,Huang2009a}.
It aimes to find which biological functions are affected by a group of 
related genes behind the massive information. The most used methotology is finding
these significant gene set from a 2 $\times$ 2 contingency table, usually by Fisher's
exact test or chi-square test. This kind of analysis is known as Over-represented
Analysis (ORA). It takes a list of differential expressed gene, and returns significant
gene sets that the differential genes are enriched in. A lot of methods have been
developed under the framework of ORA such as {DAVID} \cite{Huang2009b} (http://http://david.abcc.ncifcrf.gov/)
and \texttt{GOstats} package \cite{Falcon2007}. The second methodology to find significant
pathways is to use whole expression matrix, named Gene-set Analysis (GSA). 
GSA methods are implemented via either a univariate or a multivariate procedure \cite{Ackermann2009}. 
In univariate analysis, gene level statistics are initially calculated from fold changes 
or statistical tests (e.g., {\it t}-test). These statistics are then combined into 
a pathway level statistic by summation or averaging. GSEA \cite{Subramanian2005} 
is a widely used univariate tool that utilizes a weighted Kolmogorov-Smirnov test 
to measure the degree of differential expression of a gene set by calculating a 
running sum from the top of a ranked gene list. Multivariate analysis considers 
the correlations between genes in the pathway and calculates the pathway level 
statistic directly from the expression value matrix using Hotelling's $T^2$ test \cite{Song2006} 
or MANOVA models \cite{Hummel2008}.

For a specific form of gene sets, biological pathways are collections of correlated genes/proteins,
RNAs and compounds that work together to regulate specific biological
processes. Instead of just being a list of genes, a pathway contains 
the most important information that is how the member genes interact 
with each other. Thus network structure information is necessary for
the intepretation of the importance of the pathways.

In this package, the original pathway enrichment method
(ORA and GSA) is extended by introducing network centralities as the weight 
of nodes which have been mapped from differentially expressed genes 
in pathways \cite{Gu2012}. There are two advantages compared to former methods.
First, for the diversity of genes' characters and the difficulties of 
covering the importance of genes from all aspects, we do not design a 
fixed measurement for each gene but set it as an optional parameter in the model. 
Researchers can select from candidate choices where different measurement 
reflects different aspect of the importance of genes. 
In our model, network centralities are used to measure the importance of genes in pathways. 
Different centrality measurements assign the importance to nodes from different aspects. 
For example, degree centrality measures the amount of neighbours that 
a node directly connects to, and betweenness centrality measures how many 
information streams must pass through a certain node. Generally speaking, 
nodes having large centrality values are central nodes in the network. 
It's observed that nodes represented as metabolites, proteins or genes 
with high centralities are essential to keep the steady state of biological networks. 
Moreover, different centrality measurements may relate to different biological functions. 
The selection of centralities for researchers depends on what kind of genes 
they think important. Second, we use nodes as the basic units of pathways 
instead of genes. We observe that nodes in the pathways include different 
types of molecules, such as single gene, complex and protein families. 
Assuming a complex or family contains ten differentially expressed member genes, 
in traditional ORA, these ten genes behave as the same position as other
genes represented as single nodes, and thus they have effect of ten. 
It is not proper because these ten genes stay in a same node in the 
pathway and make functions with the effect of one node. Also, 
a same gene may locate in different complexes in a pathway and if 
taking the gene with effect of one, it would greatly decrease the importance 
of the gene. Therefore a mapping procedure from genes to pathway nodes 
is applied in our model. What's more, the nodes in pathways also include 
non-gene nodes such as microRNAs and compounds. These nodes also 
contribute to the topology of the pathway. So, when analyzing pathways, 
all types of nodes are retained.

\section{Pathway Catalogue}
Pathways are collected from public databases, such as PID, KEGG, BioCarta etc.
In \texttt{CePa} package, four catalogues (PID, KEGG, BioCarta and Reactome) from PID database have been integrated.
The pathway data are parsed from XML format file provided by the PID FTP site. 
The Perl code for parsing can be obtained from the author's website 
(http://mcube.nju.edu.cn/jwang/lab/soft/cepa/). The pathway data is stored
in \texttt{PID.db}.
\begin{Schunk}
\begin{Sinput}
> library(CePa)
> data(PID.db)
> names(PID.db)
\end{Sinput}
\begin{Soutput}
[1] "NCI"      "BioCarta" "KEGG"     "Reactome"
\end{Soutput}
\end{Schunk}

Each pathway catalogue has been stored as a \texttt{pathway.catalogue} class object.
The \texttt{print.pathway.catalogue} function simply prints the number of pathways in the catalogue.
The \texttt{plot.pathway.catalogue} function visulizes general information of the catalogue (figure \ref{f1}).
It plot:  A) Distribution of the number of member genes in each node; 
B) Distribution of the number of nodes in which a single gene resides; C) Relationship 
between node count and gene count in biological pathways. 
\begin{Schunk}
\begin{Sinput}
> class(PID.db$NCI)
\end{Sinput}
\begin{Soutput}
[1] "pathway.catalogue"
\end{Soutput}
\begin{Sinput}
> PID.db$NCI
\end{Sinput}
\begin{Soutput}
  The catalogue contains 225 pathways.
\end{Soutput}
\begin{Sinput}
> plot(PID.db$NCI)
\end{Sinput}
\end{Schunk}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f1.pdf}
\caption{Meta analysis of pathway catalogue}\label{f1}
\end{center}
\end{figure}

The pathway catalogue data contains a list of pathways and each pathway contains 
a list of interactions. There are several parts in the pathway data where three of them is must: the pathway list,
the interaction list and the mapping list. The corresponding list name are \texttt{pathList},
\texttt{interactionList} and \texttt{mapping}.
\begin{Schunk}
\begin{Sinput}
> names(PID.db$NCI)
\end{Sinput}
\begin{Soutput}
[1] "pathList"        "interactionList" "mapping"         "node.name"      
[5] "node.type"       "created" 
\end{Soutput}
\end{Schunk}

The \texttt{pathList} is a list in which each item is a list of interaction IDs
\begin{Schunk}
\begin{Sinput}
> head(PID.db$NCI$pathList[[1]])
\end{Sinput}
\begin{Soutput}
[1] "209941" "209933" "209957" "209927" "209931" "209958"
\end{Soutput}
\end{Schunk}

The \texttt{interactionList} is a three-column matrix in which the first column
is the interaction ID, the second column is the input node ID and the third column
is the output node ID.
\begin{Schunk}
\begin{Sinput}
> head(PID.db$NCI$interactionList)
\end{Sinput}
\begin{Soutput}
  interaction.id  input output
1         201405 200665 205628
2         201405 200666 205628
3         204164 208481 208484
4         204164 202538 208484
5         206327 200592 200709
6         206327 210859 200709
\end{Soutput}
\end{Schunk}

The \texttt{mapping} is the two-column matrix in which the first column is the node ID
and the second column is the gene ID.
\begin{Schunk}
\begin{Sinput}
> head(PID.db$NCI$mapping)
\end{Sinput}
\begin{Soutput}
  node.id  symbol
1  201978     HGS
2  202230 ARHGAP6
3  201405    XIAP
4  201647    CRY2
5  202024    GZMA
6  201386    HFE2
\end{Soutput}
\end{Schunk}

The pathway catalogue can also be self-defined by \texttt{set.pathway.catalogue} function. The
function returns a \texttt{pathway.catalogue} class object. E.g. we only need the
first ten pathways in NCI catalogue.
\begin{Schunk}
\begin{Sinput}
> new.catalogue = set.pathway.catalogue(pathList = PID.db$NCI$pathList[1:10],
+                 interactionList = PID.db$NCI$interactionList,
+                 mapping = PID.db$NCI$mapping)
\end{Sinput}
\end{Schunk}

In the following examples, we will use NCI catalogue as the default pathway catalogue.

\section{ORA Extension}
The pathway score is defined as the summation of the weights of differentially affected 
nodes in the pathway:
\begin{equation}\label{equation:1}
    s = \sum^n_{i = 1}{w_id_i}
\end{equation}

where $s$ is the score of the pathway, $w_i$ is the weight of the $i^{th}$ node 
and reflects the importance of the node, $n$ is the number of nodes in the pathway, 
and $d_i$ identifies whether the $i^{th}$ node is differentially affected ( $= 1$) or not ( $= 0$).

The \texttt{CePa} package needs a differentially expressed gene list and a background gene list.
The differential gene list can be obtained through variaty of methods such as
{\it t}-test, SAM \cite{Tusher2001} and limma \cite{Smyth2005}. The background gene list is the complete category of genes
that exist on a certain microarray platform or from the whole genome. The \texttt{CePa} package
contains an example gene list and a background gene list. The gene list is obtained
from a microarray study by {\it t}-test \cite{Burchard2010}.
\begin{Schunk}
\begin{Sinput}
> data(gene.list)
> names(gene.list)
\end{Sinput}
\begin{Soutput}
[1] "bk"  "dif"
\end{Soutput}
\end{Schunk}

In order to find significant pathways under several centrality measurements, we use 
\texttt{cepa.all} function.In the function, \texttt{dif} refers to the differential
gene list, \texttt{bk} refers to the background gene list and the \texttt{pc} refers
to the pathway catalogue.
\begin{Schunk}
\begin{Sinput}
> res = cepa.all(dif = gene.list$dif, bk = gene.list$bk,
+                pc = PID.db$NCI)
\end{Sinput}
\begin{Soutput}
  Calculate pathway scores...
    1/205, hif1_tfpathway...
      - equal.weight: 0.7212787
      - in.degree: 0.7972028
      - out.degree: 0.8321678
      - betweenness: 0.8031968
      - in.reach: 0.6603397
      - out.reach: 0.8141858
    ...
\end{Soutput}
\end{Schunk}

The differential gene list and the background gene list should be indicated
with the same identifiers (e.g. gene symbol or refseq ID). All genes in
the differential gene list should exist in the background gene list. In this
example, gene list must be formatted as gene symbol. If background gene list is
not specified, the function use whole human genome genes as default.

By default, \texttt{cepa.all} use \texttt{equal.weight}, \texttt{in.degree}, \texttt{out.degree},
\texttt{betweenness}, \texttt{in.reach} and \texttt{out.reach} centralities as pathway nodes' weight.
More centrality measurements can be used by setting it as a function (such as closeness,
cluster coefficient).

In order to generate the null distribution of the pathway score, novel differential
gene list is sampled from the background gene list. P-values are calculated from 1000 simulations by default.

\texttt{res} is a \texttt{cepa.all} class object. To see the general information
of this object:
\begin{Schunk}
\begin{Sinput}
> res
\end{Sinput}
\begin{Soutput}
  number of pathways: 205 

  Significant pathways (p.value <= 0.01):
               Number
  equal.weight     18
  in.degree        20
  out.degree       16
  betweenness      15
  in.reach         21
  out.reach        20
\end{Soutput}
\end{Schunk}

It will print the number of significant pathways under different centralities.
For ORA extension, \texttt{cepa.all} in fact calls \texttt{cepa.ora.all} function.
So the following code is same as the former code.
\begin{Schunk}
\begin{Sinput}
> res = cepa.ora.all(dif = gene.list$dif, bk = gene.list$bk,
+       pc = PID.db$NCI)
\end{Sinput}
\end{Schunk}

The p-values or adjusted p-values of all pathways under different centralities
can be compared through the heatmap of p-values (Figure \ref{f2}). Users can select methods to adjust
raw p-values.
\begin{Schunk}
\begin{Sinput}
> plot(res, adj.method = "BH", cutoff = 0.05)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f2.pdf}
\caption{Heatmap of p-values of all pathways}\label{f2}
\end{center}
\end{figure}

By default, \texttt{plot} generates the heatmap containing all pathways.
If only significant pathways are of interest, the \texttt{only.sig} argument
can be set to \texttt{TRUE}. (Figure \ref{f3}).
\begin{Schunk}
\begin{Sinput}
> plot(res, adj.method = "BH", only.sig = TRUE, cutoff = 0.01)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f3.pdf}
\caption{Heatmap of p-values of significant pathways}\label{f3}
\end{center}
\end{figure}

The numeric values of p-values can be obtained via \texttt{p.table}. The function
just returns the raw p-values.
\begin{Schunk}
\begin{Sinput}
> pt = p.table(res)
> head(pt)
\end{Sinput}
\begin{Soutput}
                      equal.weight   in.degree  out.degree betweenness
hif1_tfpathway         0.721278721 0.797202797 0.832167832 0.803196803
s1p_s1p5_pathway       0.144855145 0.199800200 0.160839161 0.055944056
wnt_signaling_pathway  0.869130869 0.864135864 0.907092907 0.896103896
ap1_pathway            0.002997003 0.002997003 0.000999001 0.000999001
lpa4_pathway           0.811188811 0.830169830 0.815184815 0.714285714
avb3_opn_pathway       0.796203796 0.594405594 0.649350649 0.310689311
                         in.reach   out.reach
hif1_tfpathway        0.660339660 0.814185814
s1p_s1p5_pathway      0.069930070 0.145854146
wnt_signaling_pathway 0.809190809 0.906093906
ap1_pathway           0.003996004 0.000999001
lpa4_pathway          0.765234765 0.751248751
avb3_opn_pathway      0.729270729 0.589410589
\end{Soutput}
\end{Schunk}

We can get the result for single pathway under specific centrality from the 
\texttt{cepa.all} object by identifying the index for the pathway and the index
for the centrality.
\begin{Schunk}
\begin{Sinput}
> g = get.cepa(res, id = "mapktrkpathway", cen = "in.degree")
> g
\end{Sinput}
\begin{Soutput}
  procedure: ora 
  weight: in.degree 
  p-value: 0.010 
\end{Soutput}
\end{Schunk}

\texttt{g} is a \texttt{cepa} class object. It stores information of the
evaluation of a single pathway under a single centrality. The distribution of the
pathway score and the network graph can be generated by \texttt{plot} function on the 
\texttt{cepa} object by specifying \texttt{type} argument (figure \ref{f4} and figure \ref{f5}).
\begin{Schunk}
\begin{Sinput}
> plot(g, type = "graph")
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f4.pdf}
\caption{Network visualization of a pathway}\label{f4}
\end{center}
\end{figure}

\begin{Schunk}
\begin{Sinput}
> plot(g, type = "null")
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f5.pdf}
\caption{Null distribution of pathway score}\label{f5}
\end{center}
\end{figure}

By default, \texttt{type} is set to \texttt{graph}, and the node labels is combined from member genes. The exact name for each
node can be set by \texttt{node.name} argument. Also, more detailed categories
of the nodes can be set by \texttt{node.type} argument (Figure \ref{f6}). 
\begin{Schunk}
\begin{Sinput}
> plot(g, node.name = PID.db$NCI$node.name,
+      node.type = PID.db$NCI$node.type)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f6.pdf}
\caption{Network visualization of a pathway, with node name and node type specified}\label{f6}
\end{center}
\end{figure}

For simplicity, the plotting for the \texttt{cepa} object can be directly applied
on the \texttt{cepa.all} object by specifying the index of the pathway and the 
index of the centrality (Figure \ref{f6}).
\begin{Schunk}
\begin{Sinput}
> plot(res, id = "mapktrkpathway", cen = "in.degree")
> plot(res, id = "mapktrkpathway", cen = "in.degree", type = "null")
> plot(res, id = "mapktrkpathway", cen = "in.degree",
+      node.name = PID.db$NCI$node.name,
+      node.type = PID.db$NCI$node.type)
\end{Sinput}
\end{Schunk}

If userd use \texttt{plot} to draw network graphs, the function would return an
\texttt{igraph} object. So if users are not satisfy with the default graph, they
can visulize by their own methods.
\begin{Schunk}
\begin{Sinput}
> obj = plot(res, id = "mapktrkpathway", cen = "in.degree")
> class(obj)
[1] "igraph"
\end{Sinput}
\end{Schunk}

The \texttt{igraph} package provides a \texttt{write.graph} function to output
graph into several formats. As I have tried, with \texttt{graphml} format, 
Cytoscape Web (http://http://cytoscapeweb.cytoscape.org/) can make a more beautiful
visualization of the network.
\begin{Schunk}
\begin{Sinput}
> write.graph(obj, file = "example-network.xml", format = "graphml")
> write.graph(obj, file = "example-network.gml", format = "gml")
\end{Sinput}
\end{Schunk}


Instead of analysis a list of pathways, users can also be focused on a single pathway
under a single centrality by identifying the id of the pathway in the catalogue.
\begin{Schunk}
\begin{Sinput}
> res.pathway = cepa(dif = gene.list$dif, bk = gene.list$bk,
+               pc = PID.db$NCI, id = 2)
\end{Sinput}
\end{Schunk}

Similarly, \texttt{cepa} function here directly calls \texttt{cepa.ora}.

\section{GSA extension}

In the traditional univariate GSA procedure, the score $s$ of the pathway is defined as:
\begin{equation}\label{equation:3}
    s = f(\mathbf{g})
\end{equation}

where $f$ transforms the gene-level statistic to a pathway-level statistic 
(e.g. by summation, averaging) and $\mathbf{g}$ is the gene-level statistic vector which typically 
comprises $t$-values. In ORA, $\mathbf{g}$ is a binary variant and $f(\mathbf{g})$ is summation. 
In our model to extend GSA, gene-level statistic is first transformed to node-level 
statistic. We define the vector of the node-level statistics as $\mathbf{d}$. 
When nodes in pathways comprise multiple genes, the node-level statistic can be 
considered as the largest principle component of the corresponding member genes. 
Using centrality as the weight, the score is defined as
\begin{equation}\label{equation:4}
    s = f(\mathbf{wd})
\end{equation}

where $\mathbf{w}$ is the weight vector and the transformation function $f$ acts upon 
the product of $\mathbf{w}$ and $\mathbf{d}$. Equation \ref{equation:4} incorporates centrality weight into the original node-level statistic. 
The null distribution of the pathway score could then be generated by permuting the gene expression matrix.

Since GSA procedure need a complete expression matrix, we first read the P53 microarray data set.
The \texttt{P53\_symbol.gct} and \texttt{P53.cls} can be downloaded from
http://mcube.nju.edu.cn/jwang/lab/soft/cepa/.
\begin{Schunk}
\begin{Sinput}
> eset = read.gct("P53_symbol.gct")
> # some process of the names of genes
> rownames(eset) = gsub("\\s+.*$", "", rownames(eset))
> label = read.cls("P53.cls", treatment="MUT", control="WT")
\end{Sinput}
\end{Schunk}

Here, we also use \texttt{cepa.all} to do batch pathway analysis.
\begin{Schunk}
\begin{Sinput}
> res = cepa.all(mat = eset, label = label, pc = PID.db$NCI,
                 glevel = "tvalue_sq", plevel = "mean")
\end{Sinput}
\begin{Soutput}
  Calculate gene level values.
  Calculate pathway score...
    1/205, hif1_tfpathway...
      Calculate node level value and permutate sample labels...
      - equal.weight: 0.788
      - in.degree: 0.653
      - out.degree: 0.405
      - betweenness: 0.303
      - in.reach: 0.917
      - out.reach: 0.499
    ...
\end{Soutput}
\end{Schunk}

Here, we use \texttt{mat} and \texttt{label} arguments instead of \texttt{dif} and 
\texttt{bk} arguments. In fact, when specifying \texttt{mat} and \texttt{label} arguments,
\texttt{cepa.all} calls \texttt{cepa.univaraite.all}.

In GSA procedure, first a node level statistic should be calculated. In \texttt{CePa} package,
there are three methods to calculate node level statistics. User can choose from \texttt{tvalue},
\texttt{tvalue\_abs} and \texttt{tvalue\_sq}. \texttt{tvalue\_abs} is choosen as
the default node level method because it can capture two directional regulations.
After we get the node level statistics in the pathway, a pathway level transformation
should be applied. User can choose from \texttt{max}, \texttt{min}, \texttt{median}, 
\texttt{sum}, \texttt{mean} and \texttt{rank}. \texttt{mean} is taken as default.

Print the general result of the analysis and plot figures (figure \ref{f8}).
\begin{Schunk}
\begin{Sinput}
> res
\end{Sinput}
\begin{Soutput}
  number of pathways: 205 

  Significant pathways (p.value <= 0.01):
               Number
  equal.weight      5
  in.degree         5
  out.degree        7
  betweenness       5
  in.reach          6
  out.reach         5
\end{Soutput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
> plot(res, only.sig = TRUE, adj.method = "BH", cutoff = 0.15)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\textwidth]{f8}
\caption{Heatmap of p-values of significant pathways}\label{f8}
\end{center}
\end{figure}

If we are instread in p73 pathway. First we extract this pathway under "in.degree"
centrality from \texttt{res}.

\begin{Schunk}
\begin{Sinput}
> g = get.cepa(res, id = "p73pathway", cen="in.degree")
> g
\end{Sinput}
\begin{Soutput}
  procedure: gsa.univariate 
  weight: in.degree 
  p-value: 0.002 
\end{Soutput}
\begin{Sinput}
> plot(g)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{f9}
\caption{Network visulization of a pathway}\label{f9}
\end{center}
\end{figure}

Figure \ref{f9} illustrates the graph of p73 pathway. Since the pathway is evaluated
under GSA procedure, the color of each node is continues in which red refers to up-regulated,
green refers to down-regulated and white refers to no-change.

\section{The \texttt{report} function}
One of the advantages of \texttt{CePa} package is that it can generate a detailed
report in HTML format. The function \texttt{report} is used to generate report.
The report will locate in the current working directory. By default it only generate
figures of the significant pathways, but this can be changed by setting \texttt{only.sig}
argument to \texttt{FALSE}.
\begin{Schunk}
\begin{Sinput}
> report(res)
\end{Sinput}
\begin{Soutput}
  generate images for ap1_pathway ...
  generate images for epopathway ...
  generate images for il12_stat4pathway ...
  generate images for foxm1pathway ...
  generate images for mapktrkpathway ...
  generate images for aurora_a_pathway ...
  ...

\end{Soutput}
\begin{Sinput}
> report(res, adj.method = "BH", cutoff = 0.15)
> report(res, sig.only = FALSE)
\end{Sinput}
\end{Schunk}

An example of the report can be found in figure \ref{f10}.
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.7\textwidth]{f10}
\caption{An report of the CePa analysis}\label{f10}
\end{center}
\end{figure}

\section{Parallel computing}
Since \texttt{CePa} evaluates pathways independently, the process can be realized
through parallel computing. In R statistical environment, there are many packages
focusing on parallel computing such as \texttt{snow}, \texttt{multicore}, etc. Here
we demonstrate how to apply the parallel version of \texttt{CePa}, taking \texttt{multicore}
for example.
\begin{Schunk}
\begin{Sinput}
> library(multicore)
> # identify how many cores you want to use in your computer
> ncores = 4
\end{Sinput}
\end{Schunk}

Since there are a list of pathways, we would link to divide them into several approximately
equal groups, so we have a \texttt{divide} function (maybe you have a better function like this).
\begin{Schunk}
\begin{Sinput}
> divide = function(x, k) {
+     if(length(x) ==1 && is.numeric(x)) {
+         x = 1:x
+     }
+     if(length(x) < k) {
+         stop("o")
+     }
+     w = floor(length(x)/k)
+     q = length(x) - k*w
+     d = matrix(0, nrow=k, ncol=2)
+     n = 1
+     for(i in 1:k) {
+         d[i, 1] = n
+         d[i, 2] = n+w-1+ifelse(q>0, 1, 0)
+         n = d[i,2]+1
+         q = ifelse(q > 0, q-1, 0)
+     }
+     d[k,2] = length(x)
+     return(d)
+ }
\end{Sinput}
\end{Schunk}

In the \texttt{divide} function, the first argument is a vector, usually a index vector,
and the second argument identify how many part you want to divide into. Also, the first argument
can be a positive integer. For example, we want to divide \texttt{1:10} into two groups. 
\begin{Schunk}
\begin{Sinput}
> divide(1:10, 2)
\end{Sinput}
\begin{Soutput}
     [,1] [,2]
[1,]    1    5
[2,]    6   10
\end{Soutput}
\end{Schunk}

The function returns a matrix. Rows correspond to groups and columns correspond to the start index
and the end index. If the vector can not be divided equally, the function would return an
approximately division.
\begin{Schunk}
\begin{Sinput}
> divide(1:10, 3)
\end{Sinput}
\begin{Soutput}
     [,1] [,2]
[1,]    1    4
[2,]    5    7
[3,]    8   10
\end{Soutput}
\end{Schunk}

Now we can divide the complete NCI pathway catalogue into several groups.
\begin{Schunk}
\begin{Sinput}
> NCI = PID.db$NCI
> d = divide(1:length(NCI$pathList), ncores)
\end{Sinput}
\end{Schunk}

Then we use \texttt{mclapply} which is something like a parallel version of \texttt{lapply}
to do parallele computing.
\begin{Schunk}
\begin{Sinput}
> res = mclapply(1:ncores, function(i) {
+         pc = NCI
+         pc$pathList = pc$pathList[d[i, 1]:d[i, 2]]
+         cepa.all(dif = dif, bk = bk, pc = pc)},
+         mc.cores = ncores)
> res = mclapply(1:ncores, function(i) {
+         pc = set.pathway.catalogue(pathList = PID.db$NCI$pathList[d[i, 1]:d[i, 2]],
                 interactionList = PID.db$NCI$interactionList,
                 mapping = PID.db$NCI$mapping)
+         cepa.all(mat = eset, label = label, pc = pc)},
+         mc.cores = ncores)
\end{Sinput}
\end{Schunk}

In the \texttt{mclapply}, calculation in each core would returns a \texttt{cepa.all} object.
Thus, \texttt{res} is a list of \texttt{cepa.all} objects. We need some code to transform it
into a single \texttt{cepa.all} object containing all pathways.
\begin{Schunk}
\begin{Sinput}
> obj = list()
> for(i in 1:length(res)) {
+     obj = c(obj, res[[i]])
+ }
> class(obj) = "cepa.all"
\end{Sinput}
\end{Schunk}

OK, now the \texttt{obj} is a \texttt{cepa.all} object just like the one generated from non-parallel
\texttt{CePa}.

\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}

