% \VignetteIndexEntry{CePa Vignette}
% \VignetteDepends{CePa}
% \VignetteKeywords{Pathway Enrichment Analysis}
% \VignettePackage{CePa}



\documentclass[a4paper]{article}

\title{Centrality-based Pathway Enrichment}

\author{Zuguang Gu}

\usepackage{Sweave}
\begin{document}

\maketitle 
\section{Introduction}
Gene set enrichment analysis is broadly used in microarray data analysis \cite{Khatri2005,Huang2009a}.
It aimes to find which biological functions are affected by a group of 
related genes behind the massive information. The most used methotology is finding
these significant gene set from a 2 $\times$ 2 contingency table, usually by Fisher's
exact test or chi-square test. This kind of analysis is known as Over-represented
Analysis (ORA). It takes a list of differential expressed gene, and returns significant
gene sets that the differential genes are enriched in. A lot of methods have been
developed under the framework of ORA such
as {DAVID} \cite{Huang2009b} (http://http://david.abcc.ncifcrf.gov/)
and \texttt{GOstats} package \cite{Falcon2007}.

For a specific form of gene sets, biological pathways are collections of correlated genes/proteins,
RNAs and compounds that work together to regulate specific biological
processes. Instead of just being a list of genes, a pathway contains 
the most important information that is how the member genes interact 
with each other. Thus network structure information is necessary for
the intepretation of the importance of the pathways.

In this package, the original pathway enrichment method
(ORA) is extended by introducing network centralities as the weight 
of nodes which have been mapped from differentially expressed genes 
in pathways. There are two advantages compared to former methods.
First, for the diversity of genes' characters and the difficulties of 
covering the importance of genes from all aspects, we do not design a 
fixed measurement for each gene but set it as an optional parameter in the model. 
Researchers can select from candidate choices where different measurement 
reflects different aspect of the importance of genes. 
In our model, network centralities are used to measure the importance of genes in pathways. 
Different centrality measurements assign the importance to nodes from different aspects. 
For example, degree centrality measures the amount of neighbours that 
a node directly connects to, and betweenness centrality measures how many 
information streams must pass through a certain node. Generally speaking, 
nodes having large centrality values are central nodes in the network. 
It's observed that nodes represented as metabolites, proteins or genes 
with high centralities are essential to keep the steady state of biological networks. 
Moreover, different centrality measurements may relate to different biological functions. 
The selection of centralities for researchers depends on what kind of genes 
they think important. Second, we use nodes as the basic units of pathways 
instead of genes. We observe that nodes in the pathways include different 
types of molecules, such as single gene, complex and protein families. 
Assuming a complex or family contains ten differentially expressed member genes, 
in traditional ORA, these ten genes behave as the same position as other
genes represented as single nodes, and thus they have effect of ten. 
It is not proper because these ten genes stay in a same node in the 
pathway and make functions with the effect of one node. Also, 
a same gene may locate in different complexes in a pathway and if 
taking the gene with effect of one, it would greatly decrease the importance 
of the gene. Therefore a mapping procedure from genes to pathway nodes 
is applied in our model. What's more, the nodes in pathways also include 
none-gene nodes such as microRNAs and compounds. These nodes also 
contribute to the topology of the pathway. So, when analyzing pathways, 
all types of nodes are retained.

\section{Example}
In this example, we use PID pathway catalogues which have been already integrated
in \texttt{CePa} package. The pathway data here contains a pathway list, a interaction
list and the mapping from node ids to gene ids.
\begin{Schunk}
\begin{Sinput}
> library(CePa)
> set.seed(123)
> data(PID.db)
> names(PID.db)
\end{Sinput}
\begin{Soutput}
[1] "NCI"      "BioCarta" "KEGG"     "Reactome"
\end{Soutput}
\begin{Sinput}
> names(PID.db$NCI)
\end{Sinput}
\begin{Soutput}
[1] "pathList"        "interactionList" "mapping"         "node.name"      
[5] "node.type"       "created"        
\end{Soutput}
\end{Schunk}

The \texttt{CePa} package needs a differentially expressed gene list and a background gene list.
The differential gene list can be obtained through variaty of methods such as
{\it t}-test, SAM \cite{Tusher2001} and limma \cite{Smyth2005}. The background gene list is the complete category of genes
that exist on a certain microarray platform or from the whole genome. The \texttt{CePa} package
contains an example gene list and a background gene list. The gene list is obtained
from a microarray study by {\it t}-test \cite{Burchard2010}.
\begin{Schunk}
\begin{Sinput}
> data(gene.list)
> names(gene.list)
\end{Sinput}
\begin{Soutput}
[1] "bk"  "dif"
\end{Soutput}
\end{Schunk}

\texttt{PID.db} contains four pathway catalogues which are BioCarta, NCI, Reactome
and KEGG. Among them, NCI catalogue is processed via manual curations and is recommanded
by the PID database, so in the following analysis, we use the NCI pathway catalogue.
In order to find significant pathways under several centrality measurements, use 
\texttt{cepa.all} function.
\begin{Schunk}
\begin{Sinput}
> res = cepa.all(gene.list$dif, gene.list$bk,
+       PID.db$NCI$pathList, PID.db$NCI$interactionList, PID.db$NCI$mapping)
\end{Sinput}
\begin{Soutput}
  1/207, hif1_tfpathway...
  2/207, s1p_s1p5_pathway...
  3/207, wnt_signaling_pathway...
  4/207, ap1_pathway...
  5/207, lpa4_pathway...
  ...
\end{Soutput}
\end{Schunk}

The differential gene list and the background gene list should be indicated
with the same identifiers (e.g. gene symbol or refseq ID). All genes in
the differential gene list should exist in the background gene list. In this
example, gene list must be formatted as gene symbol.

Basicly, a pathway contains a list of interactions. The \texttt{pathList} argument
is a list where elements in the list is the vector of interaction IDs 
in the pathway. The interactions in the pathway can be got from a interaction
list pool represented as \texttt{interactionList} argument. The \texttt{interactionList} argument
stores the total interaction list in the pathway catalogue. It represents
as a three columns data frame or matrix where the first column is the interaction id,
the second column is the input node id and the third column is the output node id.

The mapping data frame provide the mapping from node id to gene id. The 
first column is the node id and the second column is the gene id. By default,
it assumes every gene is the pathway is a single node.

By default, \texttt{cepa.all} use \texttt{equal.weight}, \texttt{in.degree}, \texttt{out.degree},
\texttt{betweenness}, \texttt{in.reach} and \texttt{out.reach} centralities as pathway nodes' weight.
More centrality measurements can be used by setting it as a function (such as closeness,
cluster coefficient).

In \texttt{CePa} package, the pathway data, interactions and the mappings are provided.
But users must make sure the identifier of gene should be official gene symbol
if they want to use the data.

In order to generate the null distribution of the pathway score, novel differential
gene list is sampled from the background gene list. P-values are calculated from 1000 simulations by default.

\texttt{res} is a \texttt{cepa.all} class object. To see the general information
of this object:
\begin{Schunk}
\begin{Sinput}
> res
\end{Sinput}
\begin{Soutput}
number of pathways: 207 

Significant pathways (p.value <= 0.01):
             Number
equal.weight     14
in.degree        22
out.degree       18
betweenness      15
in.reach         18
out.reach        20
\end{Soutput}
\end{Schunk}

The p-values or adjusted p-values of all pathways under different centralities
can be compared through the heatmap of p-values (Figure \ref{fig2}).
\begin{Schunk}
\begin{Sinput}
> plot(res, adj.method = "BH")
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\setkeys{Gin}{width=0.99\textwidth}
\includegraphics{CePa-006}
\caption{Heatmap of p-values of all pathways}\label{fig2}
\end{center}
\end{figure}

By default, \texttt{plot} generates the heatmap containing all pathways.
If only significant pathways are of interest, the \texttt{only.sig} argument
can be set to \texttt{TRUE}. (Figure \ref{fig3}).
\begin{Schunk}
\begin{Sinput}
> plot(res, adj.method = "BH", only.sig = TRUE)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\includegraphics{CePa-008}
\caption{Heatmap of p-values of significant pathways}\label{fig3}
\end{center}
\end{figure}

The numeric values of p-values can be obtained via \texttt{p.table}. The function
just returns the raw p-values.
\begin{Schunk}
\begin{Sinput}
> pt = p.table(res)
> head(pt)
\end{Sinput}
\begin{Soutput}
                      equal.weight   in.degree  out.degree betweenness
hif1_tfpathway         0.744255744 0.817182817 0.798201798 0.800199800
s1p_s1p5_pathway       0.136863137 0.198801199 0.138861139 0.062937063
wnt_signaling_pathway  0.886113886 0.869130869 0.898101898 0.896103896
ap1_pathway            0.001998002 0.001998002 0.001998002 0.000999001
lpa4_pathway           0.824175824 0.820179820 0.795204795 0.722277722
avb3_opn_pathway       0.752247752 0.577422577 0.644355644 0.351648352
                         in.reach   out.reach
hif1_tfpathway        0.650349650 0.807192807
s1p_s1p5_pathway      0.070929071 0.136863137
wnt_signaling_pathway 0.818181818 0.920079920
ap1_pathway           0.000999001 0.000999001
lpa4_pathway          0.776223776 0.746253746
avb3_opn_pathway      0.679320679 0.602397602
\end{Soutput}
\end{Schunk}

We can get the result for single pathway under specific centrality from the 
\texttt{cepa.all} object by identifying the index for the pathway and the index
for the centrality.
\begin{Schunk}
\begin{Sinput}
> g = get.cepa(res, "mapktrkpathway", "in.degree")
> g
\end{Sinput}
\begin{Soutput}
  diff nodes in pathway: 11 
  all nodes in pathway: 33 
  diff genes in pathway: 10 
  all genes in pathway: 33 


  weight: in.degree 
  p-value: 5.0e-03 
\end{Soutput}
\end{Schunk}

\texttt{g} is a \texttt{cepa} class object. It stores information of the
evaluation of a single pathway under a single centrality. The distribution of the
pathway score and the network graph can be generated by \texttt{plot} on the 
\texttt{cepa} object (Figure \ref{fig4}).
\begin{Schunk}
\begin{Sinput}
> plot(g)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\setkeys{Gin}{width=0.99\textwidth}
\includegraphics{CePa-012}
\caption{Summary of a single pathway under one centrality}\label{fig4}
\end{center}
\end{figure}

By default, the node labels is combined from member genes. The exact name for each
node can be set by \texttt{node.name} argument. Also, more detailed categories
of the nodes can be set by \texttt{node.type} argument (Figure \ref{fig5}). 
\begin{Schunk}
\begin{Sinput}
> plot(g, node.name = PID.db$NCI$node.name, node.type = PID.db$NCI$node.type)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\setkeys{Gin}{width=0.99\textwidth}
\includegraphics{CePa-014}
\caption{Summary of a single pathway under one centrality, with node name and node type specified}\label{fig5}
\end{center}
\end{figure}

For simplicity, the plotting for the \texttt{cepa} object can be directly applied
on the \texttt{cepa.all} object by specifying the index of the pathway and the 
index of the centrality (Figure \ref{fig6}).
\begin{Schunk}
\begin{Sinput}
> plot(res, id = "mapktrkpathway", cen = "in.degree",
+      node.name = PID.db$NCI$node.name, node.type = PID.db$NCI$node.type)
\end{Sinput}
\end{Schunk}
\begin{figure}[htbp]
\begin{center}
\setkeys{Gin}{width=0.99\textwidth}
\includegraphics{CePa-016}
\caption{Summary of a single pathway under one centrality, directly from \texttt{cepa.all} object}\label{fig6}
\end{center}
\end{figure}

\section{The \texttt{report} function}
One of the advantages of \texttt{CePa} package is that it can generate a detailed
report in HTML format. The function \texttt{report} is used to generate report.
The report will locate in the current working directory. By default it only generate
figures of the significant pathways, but this can be changed by setting \texttt{sig.only}
argument to \texttt{FALSE}.
\begin{Schunk}
\begin{Sinput}
> report(res)
\end{Sinput}
\begin{Soutput}
  generate images for ap1_pathway ...
  generate images for epopathway ...
  generate images for il12_stat4pathway ...
  generate images for foxm1pathway ...
  generate images for mapktrkpathway ...
  generate images for aurora_a_pathway ...
  ...

\end{Soutput}
\begin{Sinput}
> report(res, sig.only = FALSE)
\end{Sinput}
\end{Schunk}

\section{Parallel computing}
Since \texttt{CePa} evaluates pathways independently, the process can be realized
through parallel computing. In R statistical environment, there are many packages
focusing on parallel computing such as \texttt{snow}, \texttt{multicore}, etc. Here
we demonstrate how to apply the parallel version of \texttt{CePa}, taking \texttt{multicore}
for example.
\begin{Schunk}
\begin{Sinput}
> library(multicore)
> # identify how many cores you want to use in your computer
> ncores = 4
\end{Sinput}
\end{Schunk}

Since there are a list of pathways, we would link to divide them into several approximately
equal groups, so we have a \texttt{divide} function.
\begin{Schunk}
\begin{Sinput}
> divide = function(x, k) {
+ 	if(length(x) ==1 && is.numeric(x)) {
+ 		x = 1:x
+ 	}
+ 	if(length(x) < k) {
+ 		stop("o")
+ 	}
+ 	w = floor(length(x)/k)
+ 	q = length(x) - k*w
+ 	d = matrix(0, nrow=k, ncol=2)
+ 	n = 1
+ 	for(i in 1:k) {
+ 		d[i, 1] = n
+ 		d[i, 2] = n+w-1+ifelse(q>0, 1, 0)
+ 		n = d[i,2]+1
+ 		q = ifelse(q > 0, q-1, 0)
+ 	}
+ 	d[k,2] = length(x)
+ 	return(d)
+ }
\end{Sinput}
\end{Schunk}

In the \texttt{divide} function, the first argument is a vector, usually a index vector,
and the second argument identify how many part you want to divide into. ALso, the first argument
can be a positive integer. For example, we want to divide \texttt{1:10} into two groups. 
\begin{Schunk}
\begin{Sinput}
> divide(1:10, 2)
\end{Sinput}
\begin{Soutput}
     [,1] [,2]
[1,]    1    5
[2,]    6   10
\end{Soutput}
\end{Schunk}

The function returns a matrix. Rows correspond to groups and columns correspond to the start index
and the end index. If the vector can not be divided equally, the function would return an
approximately division.
\begin{Schunk}
\begin{Sinput}
> divide(1:10, 3)
\end{Sinput}
\begin{Soutput}
     [,1] [,2]
[1,]    1    4
[2,]    5    7
[3,]    8   10
\end{Soutput}
\end{Schunk}

Now we can divide the complete NCI pathway catalogue into several groups.
\begin{Schunk}
\begin{Sinput}
> NCI = PID.db$NCI
> d = divide(1:length(NCI$pathList), ncores)
\end{Sinput}
\end{Schunk}

Then we use \texttt{mclapply} which is something like a parallel version of \texttt{lapply}
to do parallele computing.
\begin{Schunk}
\begin{Sinput}
> res = mclapply(1:ncores, function(i) {
+                    cepa.all(dif, bk, NCI$pathList[d[i,1]:d[i,2]],
+                             NCI$interactionList,
+                             NCI$mapping)},
+                mc.cores=ncores)
\end{Sinput}
\end{Schunk}

In the \texttt{mclapply}, calculation in each core would returns a \texttt{cepa.all} object.
Thus, \texttt{res} is a list of \texttt{cepa.all} objects. We need some code to transform it
into a single \texttt{cepa.all} object containing all pathways.
\begin{Schunk}
\begin{Sinput}
> pathway.name = character(0)
> centrality = names(res[[1]]$pathway.result)
> pathway.result = list()
> for(i in 1:length(res)) {
+     pathway.name = c(pathway.name, res[[i]]$pathway.name)
+     for(cen in centrality) {
+         pathway.result[[cen]] = c(pathway.result[[cen]],
+                                   res[[i]]$pathway.result[[cen]])
+     }
+ }
> obj = list(pathway.name = pathway.name,
+            pathway.result = pathway.result)
> class(obj) = "cepa.all"
\end{Sinput}
\end{Schunk}

OK, now the \texttt{obj} is a \texttt{cepa.all} object just like the one generated from non-parallel
\texttt{CePa}.

\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}

